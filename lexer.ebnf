(* mash token literal sepcification *)

(* # this is a comment *)
COMMENT = "#" { NOT_NEWLINE } ;

(* a mash identifier. note that identifiers that match keywords are keywords *)
IDENT = ident_start { ident_chars } ;

ident_start = UNICODE_LETTER | "_" ;
ident_chars = ident_start | decimal_dig ;

(* a mash number, including both integers and floating point numbers *)
FLOAT = integer | float ;

integer = binary_num | octal_num | decimal_num | hexadecimal_num ;

(* a binary number with 0b radix spec *)
binary_num = "0b" binary_dig { binary_dig } ;
binary_dig = "0" | "1" ;

(* an octal number with 0 or 0o radix spec *)
octal_num = "0" [ "o" ] octal_dig { octal_dig } ;
octal_dig = binary_dig | "2" | "3" | "4" | "5" | "6" | "7" ;

(* a decimal number. no radix spec required *)
decimal_num = decimal_dig { decimal_dig } ;
decimal_dig = octal_dig | "8" | "9" ;

(* a hexadecimal number with a 0x radix spec *)
hexadecimal_num = "0x" hexadecimal_dig { hexadecimal_dig } ;
hexadecimal_dig = decimal_dig | "a" | "b" | "c" | "d" | "e" | "f" | "A" | "B" | "C" | "D" | "E" | "F" ;

(* a floating point number with a mantissa and exponent, separated by e or E *)
float = decimal_num [ "." decimal_num ] [ ("e" | "E") [ "+" | "-" ] decimal_num ] ;

(* a mash string value which can be lexed with strconv.Unquote *)
STRING = raw_str | escaped_str | embedded_str ;

raw_str = "`" { ANY } "`" ;

escaped_str = "\"" embedded_str "\"" ;

embedded_str = { ANY | str_escape } ;

str_escape = "\\" ( single_esc | octal_esc | x_esc | u_esc | U_esc ;
(* \n *)
single_esc = "a" | "b" | "f" | "n" | "r" | "t" | "v" | "\\" ;
(* \777 *)
octal_esc = octal_dig octal_dig octal_dig ;
(* \xFF *)
x_esc = hexadecimal_dig hexadecimal_dig ;
(* \uFFFF *)
u_esc = hexadecimal_dig hexadecimal_dig
        hexadecimal_dig hexadecimal_dig ;
(* \UFFFFFFFF *)
U_esc = hexadecimal_dig hexadecimal_dig
        hexadecimal_dig hexadecimal_dig
        hexadecimal_dig hexadecimal_dig
        hexadecimal_dig hexadecimal_dig ;

ADD = "+" ;
SUB = "-" ;
MUL = "*" ;
QUO = "/" ;
REM = "%" ;

AND =     "&" ;
OR  =     "|" ;
XOR =     "^" ;
SHL =     "<<" ;
SHR =     ">>" ;
AND_NOT = "&^" ;

ADD_ASSIGN = "+=" ;
SUB_ASSIGN = "-=" ;
MUL_ASSIGN = "*=" ;
QUO_ASSIGN = "/=" ;
REM_ASSIGN = "%=" ;

AND_ASSIGN =     "&=" ;
OR_ASSIGN  =     "|=" ;
XOR_ASSIGN =     "^=" ;
SHL_ASSIGN =     "<<=" ;
SHR_ASSIGN =     ">>=" ;
AND_NOT_ASSIGN = "&^=" ;

LAND = "&&" ;
LOR =  "||" ;

EQL    = "==" ;
LSS    = "<" ;
GTR    = ">" ;
ASSIGN = "=" ;
NOT    = "!" ;

NEQ    = "!=" ;
LEQ    = "<=" ;
GEQ    = ">=" ;
DEFINE = " ==" ;

LPAREN = "(" ;
LBRACK = "[" ;
LBRACE = "{" ;
COMMA  = "," ;

RPAREN    = ")" ;
RBRACK    = "]" ;
RBRACE    = "}" ;
SEMICOLON = ";" ;
COLON     = ":" ;

FOR  = "for" ;
IF   = "if" ;
ELIF = "elif" ;
ELSE = "else" ;

LET  = "let" ;
FUNC = "func" ;

BREAK    = "break" ;
CONTINUE = "continue" ;
RETURN   = "return" ;
