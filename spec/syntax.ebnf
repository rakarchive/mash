(* the mash script *)
program = { statement | comment } ;

(* character types *)
ANY = #'.' ;
NOT_NEWLINE = #'[^\n]' ;
UNICODE_LETTER = #'\p{L}' ;

(* mash token literal sepcification *)

(* # this is a comment *)
COMMENT = "#" { NOT_NEWLINE } ;

(* a mash identifier. note that identifiers that match keywords are keywords *)
IDENT = ident_start { ident_chars } ;

ident_start = UNICODE_LETTER | "_" ;
ident_chars = ident_start | decimal_dig ;

(* a mash number, including both integers and floating point numbers *)
FLOAT = integer | float ;

integer = binary_num | octal_num | decimal_num | hexadecimal_num ;

(* a binary number with 0b radix spec *)
binary_num = "0b" binary_dig { binary_dig } ;
binary_dig = "0" | "1" ;

(* an octal number with 0 or 0o radix spec *)
octal_num = "0" [ "o" ] octal_dig { octal_dig } ;
octal_dig = binary_dig | "2" | "3" | "4" | "5" | "6" | "7" ;

(* a decimal number. no radix spec required *)
decimal_num = decimal_dig { decimal_dig } ;
decimal_dig = octal_dig | "8" | "9" ;

(* a hexadecimal number with a 0x radix spec *)
hexadecimal_num = "0x" hexadecimal_dig { hexadecimal_dig } ;
hexadecimal_dig = decimal_dig | "a" | "b" | "c" | "d" | "e" | "f" | "A" | "B" | "C" | "D" | "E" | "F" ;

(* a floating point number with a mantissa and exponent, separated by e or E *)
float = decimal_num [ "." decimal_num ] [ ("e" | "E") [ "+" | "-" ] decimal_num ] ;

(* a mash string value which can be lexed with strconv.Unquote *)
STRING = raw_str | escaped_str ;

raw_str = "`" { ANY } "`" ;

escaped_str = "\"" embedded_str "\"" ;

embedded_str = { ANY | str_escape } ;

str_escape = "\\" ( single_esc | octal_esc | x_esc | u_esc | U_esc ) ;
(* \n *)
single_esc = "a" | "b" | "f" | "n" | "r" | "t" | "v" | "\\" ;
(* \777 *)
octal_esc = octal_dig octal_dig octal_dig ;
(* \xFF *)
x_esc = hexadecimal_dig hexadecimal_dig ;
(* \uFFFF *)
u_esc = hexadecimal_dig hexadecimal_dig
        hexadecimal_dig hexadecimal_dig ;
(* \UFFFFFFFF *)
U_esc = hexadecimal_dig hexadecimal_dig
        hexadecimal_dig hexadecimal_dig
        hexadecimal_dig hexadecimal_dig
        hexadecimal_dig hexadecimal_dig ;

ADD = "+" ;
SUB = "-" ;
MUL = "*" ;
QUO = "/" ;
REM = "%" ;

AND =     "&" ;
OR  =     "|" ;
XOR =     "^" ;
SHL =     "<<" ;
SHR =     ">>" ;
AND_NOT = "&^" ;

ADD_ASSIGN = "+=" ;
SUB_ASSIGN = "-=" ;
MUL_ASSIGN = "*=" ;
QUO_ASSIGN = "/=" ;
REM_ASSIGN = "%=" ;

AND_ASSIGN =     "&=" ;
OR_ASSIGN  =     "|=" ;
XOR_ASSIGN =     "^=" ;
SHL_ASSIGN =     "<<=" ;
SHR_ASSIGN =     ">>=" ;
AND_NOT_ASSIGN = "&^=" ;

LAND = "&&" ;
LOR =  "||" ;

EQL    = "==" ;
LSS    = "<" ;
GTR    = ">" ;
ASSIGN = "=" ;
NOT    = "!" ;

NEQ    = "!=" ;
LEQ    = "<=" ;
GEQ    = ">=" ;
DEFINE = ":=" ;

LPAREN = "(" ;
LBRACK = "[" ;
LBRACE = "{" ;
COMMA  = "," ;

RPAREN    = ")" ;
RBRACK    = "]" ;
RBRACE    = "}" ;
SEMICOLON = ";" ;
COLON     = ":" ;

FOR  = "for" ;
IF   = "if" ;
ELIF = "elif" ;
ELSE = "else" ;

LET  = "let" ;
OBJ  = "obj" ;
FUNC = "func" ;

BREAK    = "break" ;
CONTINUE = "continue" ;
RETURN   = "return" ;

(* mash formal grammar specification *)

(* comment is a mash comment *)
comment = COMMENT

(* a statement is an effector followed by a semicolon *)
statement = [ single | block ] SEMICOLON ;

(* a block statement is a list of statements *)
(* { ... } *)
block = LBRACE { statement } RBRACE ;

(* a single is a non block statement *)
single = let | if | for | cmd ;

(* let statement symbolizes an expression *)
(* 
 * let pi := 3.1415 # declaration
 * let n2 = n1 + 10 # assignment
 *)
let = LET [ assignable assign_op ] expression ;

(* assignment operator *)
assign_op = DEFINE | ASSIGN | ADD_ASSIGN | ADD_ASSIGN | MUL_ASSIGN | QUO_ASSIGN | REM_ASSIGN
          | AND_ASSIGN | OR_ASSIGN | XOR_ASSIGN | SHL_ASSIGN | SHR_ASSIGN | AND_NOT_ASSIGN ;

(* condition statement is the if-elif-else statements *)
(* if this { ... } elif that { ... }... else { ... } *)
if = IF expression block { ELIF expression block } [ ELSE block ] ;

(* loop is the for loop in c-type languages *)
(*
 * for x { ... } # conditional
 * for { ... }   # infinite
 *)
for = FOR [ expression ] block ;

(* command is a builtin or executable *)
cmd = cmd_or ;

(* various operators according to precedence *)
cmd_or = cmd_and { LOR cmd_and } ;
cmd_and = redirect { LAND redirect } ;
cmd_not = [ NOT ] redirect ;
redirect = simple_cmd { OR simple_cmd } ;
(* TODO: fix command args stuff *)
simple_cmd = cmd_arg { cmd_arg } ;

cmd_arg = STRING | embedded_str ;

(* expression is an arithmatic expression *)
(* (1 + 2) * 3 / 4 % 5 ^ 6 & 7 *)
expression = prec1 ;

(* various operator precedence levels *)

(* binary operators *)
prec1 = prec2 { op_prec1 prec2 } ;
prec2 = prec3 { op_prec2 prec3 } ;
prec3 = prec4 { op_prec3 prec4 } ;
prec4 = prec5 { op_prec4 prec5 } ;
prec5 = unary { op_prec5 unary } ;

(* unary operators *)
unary = op_unary unary | call ;

call = primary { reference } ;

(* primary is a basic constant literal or reference *)
primary = FLOAT | STRING | IDENT | function | array | object | LPAREN expression RPAREN ;

(* various operators *)
op_prec1 = LOR ;
op_prec2 = LAND ;
op_prec3 = EQL | NEQ | LSS | LEQ | GTR | GEQ ;
op_prec4 = ADD | SUB | OR | XOR ;
op_prec5 = MUL | QUO | REM | SHL | SHR | AND | AND_NOT ;
op_unary = ADD | SUB | XOR | NOT ;

(* assignable is a symbol to which an expression can be assigned *)
(* can be expanded in future to add stuff like array destructing *)
assignable = call ;

(* reference indexes a value from a complex *)
(* a a[b] a[b][c] *)
reference = LBRACK expression RBRACK | function_call ;
function_call = LPAREN [ expression { COMMA expression } [ COMMA ] ] RPAREN ;

(* a function is an anonymous function expression *)
(* func { ... } *)
function = FUNC block ;

(* arrays are list of values *)
(* [ 1, 2, 3, 4, 5 ] *)
array = LBRACK [ expression { COMMA expression } [ COMMA ] ] RBRACK ;

(* objects are keyed list of valued *)
(* [ a: 1, b: 2, c: 3, d: 4 ] *)
object = OBJ LBRACK [ object_key { COMMA object_key } [ COMMA ] ] RBRACK ;
object_key = expression COLON expression ;
