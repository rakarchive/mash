(* mash formal grammar specification *)

(* the mash script *)
program = { statement | comment } EOF ;

(* comment is a mash comment *)
comment = COMMENT

(* a statement is an effector followed by a semicolon *)
statement = [ single | block ] SEMICOLON ;

(* a block statement is a list of statements *)
(* { ... } *)
block = LBRACE { statement } RBRACE ;

(* a single is a non block statement *)
single = let | if | for | cmd ;

(* let statement symbolizes an expression *)
(* 
 * let pi := 3.1415 # declaration
 * let n2 = n1 + 10 # assignment
 *)
let = LET [ assignable assign_op ] expression ;

(* assignment operator *)
assign_op = DEFINE | ASSIGN | ADD_ASSIGN | SUM_ASSIGN | MUL_ASSIGN | QUO_ASSIGN | REM_ASSIGN
          | AND_ASSIGN | OR_ASSIGN | XOR_ASSIGN | SHL_ASSIGN | SHR_ASSIGN | AND_NOT_ASSIGN ;

(* condition statement is the if-elif-else statements *)
(* if this { ... } elif that { ... }... else { ... } *)
if = IF expression block { ELIF expression block } [ ELSE block ] ;

(* loop is the for loop in c-type languages *)
(*
 * for x { ... } # conditional
 * for { ... }   # infinite
 *)
for = FOR [ expression ] block ;

(* command is a builtin or executable *)
cmd = cmd_or ;

(* various operators according to precedence *)
cmd_or = cmd_and { LOR cmd_and } ;
cmd_and = redirect { LAND redirect } ;
cmd_not = [ NOT ] redirect ;
redirect = simple_cmd { OR simple_cmd } ;
(* TODO: fix command args stuff *)
simple_cmd = STRING { STRING } ;

(* expression is an arithmatic expression *)
(* (1 + 2) * 3 / 4 % 5 ^ 6 & 7 *)
expression = prec1 ;

(* various operator precedence levels *)

(* binary operators *)
prec1 = prec2 { op_prec1 prec2 } ;
prec2 = prec3 { op_prec2 prec3 } ;
prec3 = prec4 { op_prec3 prec4 } ;
prec4 = prec5 { op_prec4 prec5 } ;
prec5 = unary { op_prec5 unary } ;

(* unary operators *)
unary = op_unary unary | primary | complex ;

(* primary is a basic constant literal or reference *)
primary = FLOAT | STRING | reference ;
(* complexes are more complicated literal or expression *)
complex = function | array | object | LPAREN expression RPAREN ;

(* various operators *)
op_prec1 = LOR ;
op_prec2 = LAND ;
op_prec3 = EQL | NEQ | LSS | LEQ | GTR | GEQ ;
op_prec4 = ADD | SUB | OR | XOR ;
op_prec5 = MUL | QUO | REM | SHL | SHR | AND | AND_NOT ;
op_unary = ADD | SUB | XOR | NOT ;

(* assignable is a symbol to which an expression can be assigned *)
(* can be expanded in future to add stuff like array destructing *)
assignable = reference ;

(* reference indexes a value from a complex *)
(* a a[b] a[b][c] *)
reference = IDENT { LBRACK expression RBRACK | function_call } ;
function_call = LPAREN [ expression { COMMA expression } [ COMMA ] ] RPAREN ;

(* a function is an anonymous function expression *)
(* func { ... } *)
function = FUNC block ;

(* arrays are list of values *)
(* [ 1, 2, 3, 4, 5 ] *)
array = LBRACK [ expression { COMMA expression } [ COMMA ] ] RBRACK ;

(* objects are keyed list of valued *)
(* [ a: 1, b: 2, c: 3, d: 4 ] *)
object = OBJ LBRACK [ object_key { COMMA object_key } [ COMMA ] ] RBRACK ;
object_key = expression COLON expression ;
